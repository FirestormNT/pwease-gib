// Make sure M key also toggles mute/unmute
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'm') {
                toggleMute();
                e.preventDefault();
            }
        });        const characterVideo = document.getElementById('characterVideo');<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pwease Gib</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
        }
        #gameInfo {
            margin: 10px;
            color: white;
        }
        #controls {
            margin: 10px;
        }
        #controls button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            text-align: center;
            background-color: #333;
            border: 1px solid #fff;
            color: white;
            margin: 0 5px;
        }
        #controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
   canvas {
    border: 1px solid black;
    max-width: 100%;
    max-height: 80vh;
    transition: border 0.5s ease;
    background-color: #fff;
}   canvas.green-border {
            border: 5px solid green;
        }
     #characterSelect {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    background: none;
    width: 90vw; /* Removed fixed 800px */
    max-height: 80vh; /* Keep max height constraint */
    overflow-y: auto; /* Allow scrolling if content exceeds height */
    z-index: 10;
    padding: 10px; /* Add padding to prevent content from touching edges */
    box-sizing: border-box; /* Include padding in width/height calculations */
}

#videoContainer {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    width: 100%; /* Ensure it fits within parent */
}

#videoTitle {
    font-size: clamp(20px, 4vw, 36px); /* Scale between 20px and 36px based on viewport width */
    font-weight: bold;
    margin-bottom: 1vh; /* Use viewport height units for spacing */
    text-align: center;
    text-shadow: 2px 2px 4px #000;
}

#characterVideo {
    width: clamp(150px, 40vw, 300px); /* Scale between 150px and 300px */
    height: auto;
    margin-bottom: 1vh;
}
        #muteBtn {
            /* Remove specific styling and let it inherit from other buttons */
            margin: 0 5px;
        }
        #characterSelect h2 {
    margin: 1vh 0; /* Adjust spacing with viewport units */
    font-size: clamp(16px, 3vw, 24px); /* Scale header text */
}

#characterOptions {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2vh; /* Use viewport height units for spacing */
    width: 100%; /* Ensure it fits within parent */
}

.character-row {
    display: flex;
    justify-content: center;
    gap: clamp(10px, 4vw, 40px); /* Scale gap between 10px and 40px */
    flex-wrap: wrap; /* Allow wrapping on small screens */
}
        .character-option {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
     .character-option img {
    width: clamp(60px, 15vw, 124px); /* Scale between 60px and 124px */
    height: clamp(60px, 15vw, 124px); /* Maintain square aspect ratio */
    margin-bottom: 1vh;
    cursor: pointer;
    transition: transform 0.2s ease;
}
        .character-option img:hover {
            transform: scale(1.1);
        }
        .character-option.selected {
            outline: 3px solid green;
        }
        #restartBtn, #characterSelectBtn {
            display: none;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            text-align: center;
            background-color: #333;
            border: 1px solid #fff;
            color: white;
            z-index: 10;
        }
        #restartBtn {
            top: 60%;
        }
        #characterSelectBtn {
            top: 70%;
        }
        #controlInfo {
            margin-top: 10px;
            color: white;
            text-align: center;
            font-size: 14px;
        }
        #adminInput {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #55ff55;
            border-radius: 5px;
            color: #55ff55;
            font-size: 18px;
            display: none;
            z-index: 1000;
            text-align: center;
            width: 200px;
        }
        #adminInput::placeholder {
            color: rgba(85, 255, 85, 0.5);
        }
        #throwBtn, #powerUpBtn {
            display: none;
            margin-top: 10px;
            padding: 15px 30px;
            font-size: 18px;
            border: 2px solid #fff;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.1s ease, background-color 0.1s ease;
        }
        #throwBtn {
            background-color: #ff5555;
            margin-right: 10px;
        }
        #powerUpBtn {
            background-color: #55ff55;
        }
        #throwBtn:active, #powerUpBtn:active {
            transform: scale(0.95);
        }
        #throwBtn:active {
            background-color: #cc4444;
        }
        #powerUpBtn:active {
            background-color: #44cc44;
        }
        #throwBtn.pressed {
            background-color: #cc4444;
        }
        #powerUpBtn.pressed {
            background-color: #44cc44;
        }
        @media (max-width: 768px) or (pointer: coarse) {
            #throwBtn, #powerUpBtn {
                display: inline-block;
            }
            #throwBtn {
                padding: 20px 60px; /* Twice as big as #powerUpBtn */
                font-size: 24px;
            }
            #powerUpBtn {
                padding: 10px 30px; /* Standard size */
                font-size: 18px;
            }
        }
        #loadingScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 20;
        }
        /* Gamertag Entry Styles */
        #gamertagEntry {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent; /* Changed from rgba(0, 0, 0, 0.9) to transparent */
            z-index: 30;
            color: white;
        }
        #gamertagEntry h2 {
            font-size: clamp(24px, 5vw, 36px);
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px #000;
            background-color: rgba(0, 0, 0, 0.6); /* Added semi-transparent background */
            padding: 10px 20px;
            border-radius: 5px;
        }
        #gamertagInput {
            padding: 10px 15px;
            font-size: 18px;
            width: clamp(200px, 50vw, 400px);
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid #55ff55;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        #gamertagSubmit {
            padding: 10px 20px;
            font-size: 18px;
            background-color: #55ff55;
            border: none;
            border-radius: 5px;
            color: black;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #gamertagSubmit:hover {
            background-color: #44cc44;
        }
        /* We're removing this style since we won't use this element anymore
        #playerGamertagDisplay {
            position: absolute;
            top: 10px;
            left: 20px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            z-index: 15;
        }
        */
        
        /* Updated mobile control styles */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0.7));
            z-index: 100;
        }

        #throwBtn, #powerUpBtn {
            display: none;
            padding: 20px;
            font-size: 18px;
            border: 2px solid #fff;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s ease, filter 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
        }

        #throwBtn {
            background: linear-gradient(135deg, #ff5555, #ff3333);
            width: 60%;
            margin-right: 10px;
        }

        #powerUpBtn {
            background: linear-gradient(135deg, #55ff55, #33ff33);
            width: 35%;
        }

        #throwBtn:active, #powerUpBtn:active {
            transform: scale(0.95);
            filter: brightness(0.9);
        }

        /* Control Tips Tooltip */
        #controlTipsToggle {
            position: static;
            width: auto;
            height: auto;
            border-radius: 0;
            box-shadow: none;
            display: inline;
            z-index: auto;
        }

        #controlInfo {
            display: none;
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            max-width: 250px;
            z-index: 999;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #controlInfo.visible {
            display: block;
        }

        @media (max-width: 768px) or (pointer: coarse) {
            #mobileControls {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            #throwBtn, #powerUpBtn {
                display: inline-block;
            }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">Loading: 0%</div>
    <input type="text" id="adminInput" placeholder="Code Pwease">
    
    <!-- Gamertag Entry Screen -->
    <div id="gamertagEntry">
        <h2>ENTER GAMERTAG</h2>
        <input type="text" id="gamertagInput" maxlength="15" placeholder="Your gamertag...">
        <button id="gamertagSubmit">PLAY</button>
        <div style="margin-top: 30px; text-align: center;">
            <h2 style="font-size: clamp(16px, 3vw, 24px); margin-bottom: 10px;">Controls</h2>
            <div style="font-size: clamp(14px, 2.5vw, 20px); text-shadow: 2px 2px 4px #000; background-color: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 5px;">
                Move Left: A<br>
                Move Right: D<br>
                Throw: Spacebar or Throw Button (Mobile)<br>
                Pause/Resume: P<br>
                Mute/Unmute: M<br>
                Use Item: E or Item Button (Mobile)<br>
                Javelin Control: WASD
            </div>
        </div>
    </div>
    
    <div id="gameInfo">
        <span id="level">Level: 1</span> |
        <span id="score">Score: 0</span> |
        <span id="highScore">High Score: 0</span> |
        <span id="timer">Timer: 60</span>
    </div>
    <div id="controls">
        <button id="pauseBtn">PAUSE</button>
        <button id="resumeBtn" disabled>RESUME</button>
        <button id="muteBtn">MUTE</button>
        <button id="menuBtn">QUIT</button>
        <button id="controlTipsToggle">CONTROLS</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="controlInfo">
        <strong>Controls</strong><br>
        Move Left: A<br>
        Move Right: D<br>
        Throw: Spacebar or Throw Button (Mobile)<br>
        Pause/Resume: P<br>
        Mute/Unmute: M<br>
        Use Item: E or Item Button (Mobile)<br>
        Javelin Control: WASD
    </div>
    <div id="mobileControls">
        <button id="throwBtn">Throw</button>
        <button id="powerUpBtn">Item</button>
    </div>
    <div id="characterSelect">
        <div id="videoContainer">
            <div id="videoTitle">PWEASE GIB</div>
            <video id="characterVideo" autoplay loop playsinline>
                <!-- Source set via JavaScript -->
            </video>
            <!-- Removed the mute button from character select screen -->
        </div>
        <h2>Choose Your Vance</h2>
        <div id="characterOptions">
            <div class="character-row">
                <div class="character-option">
                    <img src="vancehead2.png" alt="Vance Head" id="vanceHead2Img">
                </div>
                <div class="character-option">
                    <img src="vancewithhat.png" alt="Vance with Hat" id="vanceWithHatImg">
                </div>
                <div class="character-option">
                    <img src="vancegirl.png" alt="Vance Girl" id="vanceGirlImg">
                </div>
                <div class="character-option">
                    <img src="vancesuit.png" alt="Vance Suit" id="vanceSuitImg">
                </div>
            </div>
            <div class="character-row">
                <div class="character-option">
                    <img src="vancehat2.png" alt="Vance Hat 2" id="vanceHat2Img">
                </div>
                <div class="character-option">
                    <img src="vancefat.png" alt="Vance Fat" id="vanceFatImg">
                </div>
                <div class="character-option">
                    <img src="vancechubby.png" alt="Vance Chubby" id="vanceChubbyImg">
                </div>
            </div>
        </div>
    </div>
    <button id="restartBtn">Return to 1st Level</button>
    <button id="characterSelectBtn">Return to Vance Selection</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const menuBtn = document.getElementById('menuBtn');
        const characterSelect = document.getElementById('characterSelect');
        const characterVideo = document.getElementById('characterVideo');
        const vanceHead2ImgElement = document.getElementById('vanceHead2Img');
        const vanceWithHatImgElement = document.getElementById('vanceWithHatImg');
        const vanceGirlImgElement = document.getElementById('vanceGirlImg');
        const vanceSuitImgElement = document.getElementById('vanceSuitImg');
        const vanceHat2ImgElement = document.getElementById('vanceHat2Img');
        const vanceFatImgElement = document.getElementById('vanceFatImg');
        const vanceChubbyImgElement = document.getElementById('vanceChubbyImg');
        const restartBtn = document.getElementById('restartBtn');
        const characterSelectBtn = document.getElementById('characterSelectBtn');
        const muteBtn = document.getElementById('muteBtn');
        const muteIcon = document.getElementById('muteIcon');
        const highScoreDisplay = document.getElementById('highScore');
        const throwBtn = document.getElementById('throwBtn');
        const powerUpBtn = document.getElementById('powerUpBtn');
        const loadingScreen = document.getElementById('loadingScreen');
        
        // Gamertag elements
        const gamertagEntry = document.getElementById('gamertagEntry');
        const gamertagInput = document.getElementById('gamertagInput');
        const gamertagSubmit = document.getElementById('gamertagSubmit');
        // We're not using this element anymore
        // const playerGamertagDisplay = document.getElementById('playerGamertagDisplay');
        
        let playerGamertag = '';

        // Load images
        const vanceHead2Img = new Image();
        vanceHead2Img.src = 'vancehead2.png';
        const vanceWithHatImg = new Image();
        vanceWithHatImg.src = 'vancewithhat.png';
        const vanceGirlImg = new Image();
        vanceGirlImg.src = 'vancegirl.png';
        const vanceSuitImg = new Image();
        vanceSuitImg.src = 'vancesuit.png';
        const vanceHat2Img = new Image();
        vanceHat2Img.src = 'vancehat2.png';
        const vanceFatImg = new Image();
        vanceFatImg.src = 'vancefat.png';
        const vanceChubbyImg = new Image();
        vanceChubbyImg.src = 'vancechubby.png';
        const zelenskyImg = new Image();
        zelenskyImg.src = 'zelenskyhead3.png';
        const putinImg = new Image();
        putinImg.src = 'putinhead.png';
        const lollipopImg = new Image();
        lollipopImg.src = 'lollipop.png';
        const officeImg = new Image();
        officeImg.src = 'officepixel.png';
        const hallwayImg = new Image();
        hallwayImg.src = 'hallway.png';
        const lawnImg = new Image();
        lawnImg.src = 'lawn.png';
        const ballroomImg = new Image();
        ballroomImg.src = 'ballroom.png';
        const bedroomImg = new Image();
        bedroomImg.src = 'bedroom.png';
        const conferenceroomImg = new Image();
        conferenceroomImg.src = 'conferenceroom.png';
        const diningImg = new Image();
        diningImg.src = 'dining.png';
        const trumpImg = new Image();
        trumpImg.src = 'trumphead.png';
        const cybertruckImg = new Image();
        cybertruckImg.src = 'cybertruck.png';
        const explosionImg = new Image();
        explosionImg.src = 'explosion.png';
        const javelinImg = new Image();
        javelinImg.src = 'javelin.png';
        const missileImg = new Image();
        missileImg.src = 'missile.png';
        missileImg.onload = () => {
            imageLoaded(missileImg);
            console.log('Missile image loaded successfully');
        };
        missileImg.onerror = () => {
            console.error('Failed to load missile image');
            imageError(missileImg);
        };
        const hallway2Img = new Image(); // New background
        hallway2Img.src = 'hallway2.png';
        const gameroomImg = new Image(); // New background
        gameroomImg.src = 'gameroom.png';
        const lawn2Img = new Image(); // New background
        lawn2Img.src = 'lawn2.png';

        // Load sound effects
        const selectSound = new Audio('selectsound.wav');
        const explosionSound = new Audio('explosion.wav');
        const shootSound = new Audio('shoot.wav');
        const enlargedSound = new Audio('enlarged.wav');
        const hitSoundPool = [new Audio('hit.wav'), new Audio('hit.wav'), new Audio('hit.wav')];
        let hitSoundIndex = 0;
        const deadSound = new Audio('dead.wav');
        const hoverSound = new Audio('hover.wav');
        const timerSound = new Audio('timer.wav');
        const itemSound = new Audio('item.wav');
        const clapSound = new Audio('clap.wav');
        const pauseSound = new Audio('pause.wav');
        const resumedSound = new Audio('resumed.wav');
        const missileLaunchSound = new Audio('missile_launch1.wav');
        const missileFlyingSound = new Audio('missileflying.wav');

        const backgrounds = [officeImg, hallwayImg, lawnImg, ballroomImg, bedroomImg, conferenceroomImg, diningImg, hallway2Img, gameroomImg, lawn2Img]; // Updated with new backgrounds
        let currentBackgroundIndex = 0;

        let selectedVanceImg = null;
        let gameOverText = null;
        let highScore = localStorage.getItem('highScore') || 0;
        highScoreDisplay.textContent = `High Score: ${highScore}`;
        let currentPowerUp = null;

        // Add after other variable declarations
        let vanceInventory = null; // Store collected Vance power-up
        let vanceDropTimer = 30; // Timer for Vance power-up drop
        let vanceDrops = []; // Array to store active Vance drops

        // Add after other image arrays
        const vanceDropImages = [
            vanceHead2Img,
            vanceWithHatImg,
            vanceGirlImg,
            vanceSuitImg,
            vanceHat2Img,
            vanceFatImg,
            vanceChubbyImg
        ];

        // Preload images and set up video
        let imagesLoaded = 0;
        const totalImages = 24; // Updated to 24 with 3 new backgrounds
        function imageLoaded(img) {
            imagesLoaded++;
            loadingScreen.textContent = `Loading: ${Math.floor((imagesLoaded / totalImages) * 100)}%`;
            if (imagesLoaded === totalImages) {
                loadingScreen.style.display = 'none';
                // Show gamertag entry with hallway2 background
                drawHallwayBackground();
                gamertagEntry.style.display = 'flex';
            }
        }
        
        // Function to draw hallway2 background for gamertag entry
        function drawHallwayBackground() {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Use hallway2Img as background
            if (hallway2Img.complete) {
                ctx.drawImage(hallway2Img, 0, 0, canvas.width, canvas.height);
            }
        }
        function imageError(img) {
            console.error(`Failed to load image: ${img.src}`);
        }
        vanceHead2Img.onload = () => imageLoaded(vanceHead2Img);
        vanceHead2Img.onerror = () => imageError(vanceHead2Img);
        vanceWithHatImg.onload = () => imageLoaded(vanceWithHatImg);
        vanceWithHatImg.onerror = () => imageError(vanceWithHatImg);
        vanceGirlImg.onload = () => imageLoaded(vanceGirlImg);
        vanceGirlImg.onerror = () => imageError(vanceGirlImg);
        vanceSuitImg.onload = () => imageLoaded(vanceSuitImg);
        vanceSuitImg.onerror = () => imageError(vanceSuitImg);
        vanceHat2Img.onload = () => imageLoaded(vanceHat2Img);
        vanceHat2Img.onerror = () => imageError(vanceHat2Img);
        vanceFatImg.onload = () => imageLoaded(vanceFatImg);
        vanceFatImg.onerror = () => imageError(vanceFatImg);
        vanceChubbyImg.onload = () => imageLoaded(vanceChubbyImg);
        vanceChubbyImg.onerror = () => imageError(vanceChubbyImg);
        zelenskyImg.onload = () => imageLoaded(zelenskyImg);
        zelenskyImg.onerror = () => imageError(zelenskyImg);
        putinImg.onload = () => imageLoaded(putinImg);
        putinImg.onerror = () => imageError(putinImg);
        lollipopImg.onload = () => imageLoaded(lollipopImg);
        lollipopImg.onerror = () => imageError(lollipopImg);
        officeImg.onload = () => imageLoaded(officeImg);
        officeImg.onerror = () => imageError(officeImg);
        hallwayImg.onload = () => imageLoaded(hallwayImg);
        hallwayImg.onerror = () => imageError(hallwayImg);
        lawnImg.onload = () => imageLoaded(lawnImg);
        lawnImg.onerror = () => imageError(lawnImg);
        ballroomImg.onload = () => imageLoaded(ballroomImg);
        ballroomImg.onerror = () => imageError(ballroomImg);
        bedroomImg.onload = () => imageLoaded(bedroomImg);
        bedroomImg.onerror = () => imageError(bedroomImg);
        conferenceroomImg.onload = () => imageLoaded(conferenceroomImg);
        conferenceroomImg.onerror = () => imageError(conferenceroomImg);
        diningImg.onload = () => imageLoaded(diningImg);
        diningImg.onerror = () => imageError(diningImg);
        trumpImg.onload = () => imageLoaded(trumpImg);
        trumpImg.onerror = () => imageError(trumpImg);
        cybertruckImg.onload = () => imageLoaded(cybertruckImg);
        cybertruckImg.onerror = () => imageError(cybertruckImg);
        explosionImg.onload = () => imageLoaded(explosionImg);
        explosionImg.onerror = () => imageError(explosionImg);
        javelinImg.onload = () => imageLoaded(javelinImg);
        javelinImg.onerror = () => imageError(javelinImg);
        missileImg.onload = () => imageLoaded(missileImg);
        missileImg.onerror = () => imageError(missileImg);
        hallway2Img.onload = () => imageLoaded(hallway2Img); // New background
        hallway2Img.onerror = () => imageError(hallway2Img);
        gameroomImg.onload = () => imageLoaded(gameroomImg); // New background
        gameroomImg.onerror = () => imageError(gameroomImg);
        lawn2Img.onload = () => imageLoaded(lawn2Img); // New background
        lawn2Img.onerror = () => imageError(lawn2Img);

        // Gamertag functionality
        gamertagSubmit.addEventListener('click', submitGamertag);
        gamertagInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                submitGamertag();
            }
        });

        function submitGamertag() {
            const gamertag = gamertagInput.value.trim();
            if (gamertag) {
                playerGamertag = gamertag;
                
                // Save in localStorage for persistence
                localStorage.setItem('playerGamertag', playerGamertag);
                
                // Set audio to unmuted by default
                localStorage.setItem('videoMuted', 'false');
                characterVideo.muted = false;
                allAudios.forEach(audio => {
                    audio.muted = false;
                });
                updateMuteButtonText(false);
                
                // Hide gamertag entry and show character select
                gamertagEntry.style.display = 'none';
                setupCharacterVideo();
                drawBackground();
                characterSelect.style.display = 'flex';
                initCharacterSelectKeyboard();
            } else {
                // Shake input or show error
                gamertagInput.style.border = '2px solid red';
                setTimeout(() => {
                    gamertagInput.style.border = '2px solid #55ff55';
                }, 1000);
            }
        }

        // Check for saved gamertag on load
        if (localStorage.getItem('playerGamertag')) {
            playerGamertag = localStorage.getItem('playerGamertag');
            gamertagInput.value = playerGamertag;
        }

        // Setup random video selection with mute persistence
        function setupCharacterVideo() {
            const videos = ['vance3d.mp4', 'vance3d2.mp4', 'strobe.mp4', 'retrowave.mp4'];
            const randomVideo = videos[Math.floor(Math.random() * videos.length)];
            characterVideo.innerHTML = '';
            const source = document.createElement('source');
            source.src = randomVideo;
            source.type = 'video/mp4';
            characterVideo.appendChild(source);
            const isMuted = localStorage.getItem('videoMuted') === 'true';
            characterVideo.muted = isMuted;
            updateMuteButtonText(isMuted);
            characterVideo.load();
            characterVideo.play().catch(error => {
                console.error("Video playback failed:", error);
                characterSelect.style.display = 'flex';
            });
        }

        function updateMuteButtonText(isMuted) {
            muteBtn.textContent = isMuted ? "UNMUTE" : "MUTE";
        }

        function toggleMute() {
            // Toggle mute for character video if it exists
            if (characterVideo) {
                characterVideo.muted = !characterVideo.muted;
            }
            
            // Toggle mute for all audio elements
            const allAudios = [
                selectSound, explosionSound, shootSound, enlargedSound, 
                ...hitSoundPool, deadSound, hoverSound, timerSound, 
                itemSound, clapSound, pauseSound, resumedSound,
                missileLaunchSound, missileFlyingSound
            ];
            
            const isMuted = localStorage.getItem('videoMuted') === 'true';
            const newMuteState = !isMuted;
            
            allAudios.forEach(audio => {
                audio.muted = newMuteState;
            });
            
            updateMuteButtonText(newMuteState);
            localStorage.setItem('videoMuted', newMuteState);
        }

        // Check initial mute state from localStorage
        const initialMuted = localStorage.getItem('videoMuted') === 'true';
        updateMuteButtonText(initialMuted);
        
        // Set initial mute state for all audio elements
        const allAudios = [
            selectSound, explosionSound, shootSound, enlargedSound, 
            ...hitSoundPool, deadSound, hoverSound, timerSound, 
            itemSound, clapSound, pauseSound, resumedSound,
            missileLaunchSound, missileFlyingSound
        ];
        
        allAudios.forEach(audio => {
            audio.muted = initialMuted;
        });
        
        // Global mute key handler
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'm') {
                toggleMute();
                e.preventDefault();
            }
        });
        
        muteBtn.addEventListener('click', toggleMute);

        const BASE_CANVAS_WIDTH = 800;
        let scaleFactor = canvas.width / BASE_CANVAS_WIDTH;

        const player = {
            x: 400,
            baseWidth: 62,
            baseHeight: 62,
            displayWidth: 62 * scaleFactor,
            displayHeight: 62 * scaleFactor,
            targetWidth: 62 * scaleFactor,
            targetHeight: 62 * scaleFactor,
            baseSpeed: 5,
            speed: 5 * scaleFactor,
            text: null,
            textTimer: 0,
            invincible: false,
            invincibleTimer: 0,
            sizeMultiplier: 1,
            sizeTransition: 1,
            sizeTransitionSpeed: 2,
            explosion: null
        };

        let lollipops = [];
        let zelenskyHeads = [];
        let putinHeads = [];
        let trumpHeads = [];
        let cybertrucks = [];
        let javelins = [];
        let missile = null;
        let textEffects = [];
        let level = 1;
        let score = 0;
        let timeLeft = 60;
        let gameActive = false;
        let gamePaused = false;
        let levelTransition = false;
        let transitionTimer = 3;
        let gibMoneyTimer = 0;
        let trumpSpawnTimer = 39;
        let cybertruckSpawnTimer = 33;
        let javelinSpawnTimer = 26;
        let lastTrumpSpawnTime = 60;
        let lastCybertruckSpawnTime = 60;
        let lastJavelinSpawnTime = 60;
        let gameTimer = null;
        let animationFrameId = null;

        let touchLeft = false;
        let touchRight = false;

        const levels = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];

        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        function drawBackground() {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const currentBackground = backgrounds[currentBackgroundIndex];
            if (currentBackground.complete) {
                ctx.drawImage(currentBackground, 0, 0, canvas.width, canvas.height);
            }
        }

        let selectedCharacterIndex = 0;
        const characterOptions = [
            vanceHead2ImgElement, vanceWithHatImgElement, vanceGirlImgElement, vanceSuitImgElement,
            vanceHat2ImgElement, vanceFatImgElement, vanceChubbyImgElement
        ];
        const characterImages = [
            vanceHead2Img, vanceWithHatImg, vanceGirlImg, vanceSuitImg,
            vanceHat2Img, vanceFatImg, vanceChubbyImg
        ];

        function updateCharacterSelection() {
            characterOptions.forEach((option, index) => {
                option.parentElement.classList.toggle('selected', index === selectedCharacterIndex);
            });
        }

        function initCharacterSelectKeyboard() {
            updateCharacterSelection();
            document.addEventListener('keydown', handleCharacterSelectKeys);
        }

        function handleCharacterSelectKeys(e) {
            if (characterSelect.style.display !== 'flex') return;
            if (e.key === 'ArrowLeft') {
                selectedCharacterIndex = (selectedCharacterIndex - 1 + characterOptions.length) % characterOptions.length;
                hoverSound.play();
                updateCharacterSelection();
                e.preventDefault();
            } else if (e.key === 'ArrowRight') {
                selectedCharacterIndex = (selectedCharacterIndex + 1) % characterOptions.length;
                hoverSound.play();
                updateCharacterSelection();
                e.preventDefault();
            } else if (e.key === 'Enter') {
                selectedVanceImg = characterImages[selectedCharacterIndex];
                characterSelect.style.display = 'none';
                characterVideo.pause();
                selectSound.play();
                drawInitialScreen();
                startGame();
                document.removeEventListener('keydown', handleCharacterSelectKeys);
                e.preventDefault();
            }
            // Removed specific M key handling here since we now have global M key handling
        }

        vanceHead2ImgElement.addEventListener('mouseover', () => hoverSound.play());
        vanceHead2ImgElement.addEventListener('click', () => {
            selectedVanceImg = vanceHead2Img;
            characterSelect.style.display = 'none';
            characterVideo.pause();
            selectSound.play();
            drawInitialScreen();
            startGame();
        });

        vanceWithHatImgElement.addEventListener('mouseover', () => hoverSound.play());
        vanceWithHatImgElement.addEventListener('click', () => {
            selectedVanceImg = vanceWithHatImg;
            characterSelect.style.display = 'none';
            characterVideo.pause();
            selectSound.play();
            drawInitialScreen();
            startGame();
        });

        vanceGirlImgElement.addEventListener('mouseover', () => hoverSound.play());
        vanceGirlImgElement.addEventListener('click', () => {
            selectedVanceImg = vanceGirlImg;
            characterSelect.style.display = 'none';
            characterVideo.pause();
            selectSound.play();
            drawInitialScreen();
            startGame();
        });

        vanceSuitImgElement.addEventListener('mouseover', () => hoverSound.play());
        vanceSuitImgElement.addEventListener('click', () => {
            selectedVanceImg = vanceSuitImg;
            characterSelect.style.display = 'none';
            characterVideo.pause();
            selectSound.play();
            drawInitialScreen();
            startGame();
        });

        vanceHat2ImgElement.addEventListener('mouseover', () => hoverSound.play());
        vanceHat2ImgElement.addEventListener('click', () => {
            selectedVanceImg = vanceHat2Img;
            characterSelect.style.display = 'none';
            characterVideo.pause();
            selectSound.play();
            drawInitialScreen();
            startGame();
        });

        vanceFatImgElement.addEventListener('mouseover', () => hoverSound.play());
        vanceFatImgElement.addEventListener('click', () => {
            selectedVanceImg = vanceFatImg;
            characterSelect.style.display = 'none';
            characterVideo.pause();
            selectSound.play();
            drawInitialScreen();
            startGame();
        });

        vanceChubbyImgElement.addEventListener('mouseover', () => hoverSound.play());
        vanceChubbyImgElement.addEventListener('click', () => {
            selectedVanceImg = vanceChubbyImg;
            characterSelect.style.display = 'none';
            characterVideo.pause();
            selectSound.play();
            drawInitialScreen();
            startGame();
        });

        const keys = {};
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !gameActive && gameOverText) {
                resetGame();
                return;
            }
            if (!gameActive) return;
            keys[e.key] = true;
            if (e.key === 'p' && !levelTransition) {
                if (!gamePaused) {
                    gamePaused = true;
                    pauseBtn.disabled = true;
                    resumeBtn.disabled = false;
                    pauseSound.play();
                } else {
                    gamePaused = false;
                    pauseBtn.disabled = false;
                    resumeBtn.disabled = true;
                    resumedSound.play();
                    lastTime = performance.now();
                }
            }
            if (e.key.toLowerCase() === 'e' && currentPowerUp) {
                if (currentPowerUp === 'javelin') {
                    launchMissile();
                } else if (currentPowerUp === 'cybertruck') {
                    triggerCybertruckExplosion();
                }
            }
            if (e.key === ' ') shootLollipop();
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        document.body.addEventListener('touchstart', (e) => {
            if (!gameActive || gamePaused || levelTransition || characterSelect.style.display === 'flex') return;
            e.preventDefault();
            
            // If missile is active, start tracking touch for missile control
            if (missile) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Only control missile if touch is within canvas bounds
                if (touchX >= 0 && touchX <= canvas.width && touchY >= 0 && touchY <= canvas.height) {
                    missile.lastTouchX = touchX;
                    missile.lastTouchY = touchY;
                }
                return;
            }

            // Existing player movement controls
            for (let touch of e.touches) {
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                if (touchY > canvas.offsetTop && touchY < canvas.offsetTop + canvas.height) {
                    if (touchX < window.innerWidth / 3) {
                        touchLeft = true;
                    } else if (touchX > window.innerWidth * 2 / 3) {
                        touchRight = true;
                    }
                }
            }
        });

        document.body.addEventListener('touchmove', (e) => {
            if (!gameActive || gamePaused || levelTransition || characterSelect.style.display === 'flex') return;
            e.preventDefault();
            
            // If missile is active, update its position based on touch movement
            if (missile) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Only move missile if touch is within canvas bounds
                if (touchX >= 0 && touchX <= canvas.width && touchY >= 0 && touchY <= canvas.height) {
                    if (missile.lastTouchX !== undefined && missile.lastTouchY !== undefined) {
                        const deltaX = touchX - missile.lastTouchX;
                        const deltaY = touchY - missile.lastTouchY;
                        
                        missile.x += deltaX;
                        missile.y += deltaY;
                        
                        // Keep missile within canvas bounds
                        missile.x = Math.max(0, Math.min(canvas.width - missile.width, missile.x));
                        missile.y = Math.max(0, Math.min(canvas.height - missile.height, missile.y));
                    }
                    missile.lastTouchX = touchX;
                    missile.lastTouchY = touchY;
                }
                return;
            }

            // Existing player movement controls
            touchLeft = false;
            touchRight = false;
            for (let touch of e.touches) {
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                if (touchY > canvas.offsetTop && touchY < canvas.offsetTop + canvas.height) {
                    if (touchX < window.innerWidth / 3) {
                        touchLeft = true;
                    } else if (touchX > window.innerWidth * 2 / 3) {
                        touchRight = true;
                    }
                }
            }
        });

        document.body.addEventListener('touchend', (e) => {
            if (!gameActive || gamePaused || levelTransition || characterSelect.style.display === 'flex') return;
            e.preventDefault();
            
            // Clear missile touch tracking when touch ends
            if (missile) {
                missile.lastTouchX = undefined;
                missile.lastTouchY = undefined;
            }
            
            touchLeft = false;
            touchRight = false;
        });

        throwBtn.addEventListener('touchstart', (e) => {
            if (!gameActive || gamePaused || levelTransition) return;
            e.preventDefault();
            shootLollipop();
            throwBtn.classList.add('pressed');
            setTimeout(() => throwBtn.classList.remove('pressed'), 100);
        });

        powerUpBtn.addEventListener('touchstart', (e) => {
            if (!gameActive || gamePaused || levelTransition || !currentPowerUp) return;
            e.preventDefault();
            if (currentPowerUp === 'javelin') {
                launchMissile();
            } else if (currentPowerUp === 'cybertruck') {
                triggerCybertruckExplosion();
            }
            powerUpBtn.classList.add('pressed');
            setTimeout(() => powerUpBtn.classList.remove('pressed'), 100);
        });

        pauseBtn.addEventListener('click', () => {
            if (gameActive && !gamePaused && !levelTransition) {
                gamePaused = true;
                pauseBtn.disabled = true;
                resumeBtn.disabled = false;
                pauseSound.play();
            }
        });
        resumeBtn.addEventListener('click', () => {
            if (gameActive && gamePaused && !levelTransition) {
                gamePaused = false;
                pauseBtn.disabled = false;
                resumeBtn.disabled = true;
                resumedSound.play();
                lastTime = performance.now();
            }
        });

        menuBtn.addEventListener('click', () => {
            if (gameActive) {
                returnToCharacterSelect();
            }
        });

        restartBtn.addEventListener('click', () => {
            resetGame();
        });

        characterSelectBtn.addEventListener('click', () => {
            returnToCharacterSelect();
        });

        function resizeCanvas() {
            const isMobile = window.innerWidth <= 768 || window.matchMedia('(pointer: coarse)').matches;
            const aspectRatio = isMobile ? 9/16 : 800/600; // Vertical 16:9 on mobile, regular on desktop
            
            let newWidth, newHeight;
            
            if (isMobile) {
                // On mobile, make it fill most of the screen height
                newHeight = window.innerHeight * 0.7;
                newWidth = newHeight * aspectRatio;
                
                // If width is too wide, constrain it
                if (newWidth > window.innerWidth * 0.95) {
                    newWidth = window.innerWidth * 0.95;
                    newHeight = newWidth / aspectRatio;
                }
            } else {
                // Desktop sizing remains the same
                newWidth = window.innerWidth * 0.9;
                newHeight = newWidth / aspectRatio;
                
                if (newHeight > window.innerHeight * 0.8) {
                    newHeight = window.innerHeight * 0.8;
                    newWidth = newHeight * aspectRatio;
                }
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            scaleFactor = canvas.width / BASE_CANVAS_WIDTH;

            player.speed = player.baseSpeed * scaleFactor;

            player.x = canvas.width / 2 - player.baseWidth / 2;
            player.displayWidth = player.baseWidth * scaleFactor * player.sizeMultiplier;
            player.displayHeight = player.baseHeight * scaleFactor * player.sizeMultiplier;
            player.targetWidth = player.baseWidth * scaleFactor * player.sizeMultiplier;
            player.targetHeight = player.baseHeight * scaleFactor * player.sizeMultiplier;

            // Update all game entities with new scale
            // ... existing entity updates ...

            if (!gameActive) {
                if (gamertagEntry.style.display === 'flex') {
                    drawHallwayBackground();
                } else {
                    drawBackground();
                    if (characterSelect.style.display === 'none' && selectedVanceImg) {
                        drawInitialScreen();
                    }
                }
            } else {
                draw();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Add mobile/desktop switch detection
        const mobileQuery = window.matchMedia('(max-width: 768px), (pointer: coarse)');
        let wasMobile = mobileQuery.matches;

        // Function to show refresh message
        function showRefreshMessage() {
            const message = document.createElement('div');
            message.style.position = 'fixed';
            message.style.top = '50%';
            message.style.left = '50%';
            message.style.transform = 'translate(-50%, -50%)';
            message.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            message.style.color = 'white';
            message.style.padding = '20px';
            message.style.borderRadius = '10px';
            message.style.fontSize = '24px';
            message.style.zIndex = '9999';
            message.textContent = 'Reloading from Resize';
            document.body.appendChild(message);
            
            // Refresh after showing message
            setTimeout(() => {
                location.reload();
            }, 1000);
        }

        // Listen for changes in the media query
        mobileQuery.addEventListener('change', (e) => {
            const isMobileNow = e.matches;
            if (wasMobile !== isMobileNow) {
                // View has changed between mobile and desktop
                showRefreshMessage();
            }
            wasMobile = isMobileNow;
        });

        function drawInitialScreen() {
            drawBackground();
            if (selectedVanceImg && selectedVanceImg.complete) {
                ctx.drawImage(selectedVanceImg, player.x, canvas.height - player.displayHeight, player.displayWidth, player.displayHeight);
            }
        }

        function spawnZelenskyHeads(count) {
            zelenskyHeads = [];
            for (let i = 0; i < count; i++) {
                zelenskyHeads.push({
                    x: Math.random() * (canvas.width - 41 * scaleFactor),
                    y: Math.random() * (canvas.height / 2),
                    width: 41 * scaleFactor,  // Updated to include scaleFactor here
                    height: 61 * scaleFactor, // Updated to include scaleFactor here
                    displayWidth: 41 * scaleFactor,
                    displayHeight: 61 * scaleFactor,
                    speedX: (Math.random() - 0.5) * 2.5 * scaleFactor,
                    speedY: (Math.random() - 0.5) * 2.5 * scaleFactor,
                    text: null,
                    textTimer: 0
                });
            }
        }

     function spawnPutinHead() {
    const padding = 100 * scaleFactor;
    const minX = padding;
    const maxX = canvas.width - (41 * scaleFactor) - padding;
    const spawnX = minX + Math.random() * (maxX - minX);
    putinHeads.push({
        x: spawnX,
        y: Math.random() * (canvas.height / 2),
        width: 41 * scaleFactor,  // Updated to include scaleFactor here
        height: 61 * scaleFactor, // Updated to include scaleFactor here
        displayWidth: 41 * scaleFactor,
        displayHeight: 61 * scaleFactor,
        speedX: (Math.random() - 0.5) * 2.5 * scaleFactor,
        speedY: (Math.random() - 0.5) * 2.5 * scaleFactor,
        text: "WWIII!",
        textTimer: Infinity,
        isSmall: false
    });
}

function spawnSmallPutinHeads(x, y, count) {
    const spread = 50 * scaleFactor;
    const minX = 0;
    const maxX = canvas.width - (24 * scaleFactor);
    
    for (let i = 0; i < count; i++) {
        let spawnX = x + (Math.random() - 0.5) * spread;
        spawnX = Math.max(minX, Math.min(maxX, spawnX));
        
        putinHeads.push({
            x: spawnX,
            y: y,
            spawnY: y,
            width: 24 * scaleFactor,
            height: 36 * scaleFactor,
            displayWidth: 24 * scaleFactor,
            displayHeight: 36 * scaleFactor,
            speedX: (Math.random() - 0.5) * 3 * scaleFactor,
            speedY: -3 * scaleFactor, // Reduced from -5 to -3.5 (30% slower)
            gravity: 0.1 * scaleFactor, // Reduced from 0.2 to 0.14 (30% slower)
            text: null,
            textTimer: 0,
            isSmall: true,
            hasLanded: false
        });
    }
}

        function spawnTrumpHead() {
            trumpHeads.push({
                x: Math.random() * (canvas.width - 100 * scaleFactor),
                y: -62 * scaleFactor,
                width: 100 * scaleFactor,
                height: 62 * scaleFactor,
                speedY: 2.5 * scaleFactor,
                text: "MAGA"
            });
            lastTrumpSpawnTime = Math.floor(timeLeft);
            trumpSpawnTimer = 39;
        }

        function spawnCybertruck() {
            cybertrucks.push({
                x: Math.random() * (canvas.width - 60 * scaleFactor),
                y: -30 * scaleFactor,
                width: 60 * scaleFactor,
                height: 30 * scaleFactor,
                speedY: 2.5 * scaleFactor,
            });
            lastCybertruckSpawnTime = Math.floor(timeLeft);
            cybertruckSpawnTimer = 33;
        }

        function spawnJavelin() {
            javelins.push({
                x: Math.random() * (canvas.width - 60 * scaleFactor),
                y: -60 * scaleFactor,
                width: 60 * scaleFactor,
                height: 60 * scaleFactor,
                speedY: 2.5 * scaleFactor,
            });
            lastJavelinSpawnTime = Math.floor(timeLeft);
            javelinSpawnTimer = 26;
        }

        function shootLollipop() {
            const lollipop = {
                x: player.x + (player.displayWidth - (10 * 1.3 * scaleFactor)) / 2,
                y: canvas.height - player.displayHeight,
                width: 10 * 1.3 * scaleFactor,
                height: 20 * 1.3 * scaleFactor,
                speed: -6 * scaleFactor,
            };
            lollipops.push(lollipop);
            player.text = "Say Pwease";
            player.textTimer = 1;
            shootSound.play();
        }

        function triggerCybertruckExplosion() {
            if (currentPowerUp === 'cybertruck') {
                player.explosion = {
                    x: player.x + player.displayWidth / 2,
                    y: canvas.height - player.displayHeight / 2,
                    baseWidth: 200 * scaleFactor,
                    baseHeight: 200 * scaleFactor,
                    width: 200 * scaleFactor,
                    height: 200 * scaleFactor,
                    timer: 2,
                    sizeTimer: 0.5
                };
                currentPowerUp = null;
                explosionSound.play();
            }
        }

        function launchMissile() {
            if (currentPowerUp === 'javelin' && missileImg.complete) {
                missile = {
                    x: player.x + player.displayWidth / 2 - (90 * scaleFactor) / 2,
                    y: canvas.height - player.displayHeight,
                    width: 90 * scaleFactor,
                    height: 45 * scaleFactor,
                    speed: 5 * scaleFactor,
                    explosion: null,
                    lifetime: 3,
                    lastTouchX: undefined,
                    lastTouchY: undefined
                };
                currentPowerUp = null;
                missileLaunchSound.play();
                missileFlyingSound.loop = true;
                missileFlyingSound.play();
            }
        }

        function resetGameState(fullReset = false) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (gameTimer) clearInterval(gameTimer);

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
                highScoreDisplay.textContent = `High Score: ${highScore}`;
            }

            level = 1;
            score = 0;
            timeLeft = 60;
            currentBackgroundIndex = 0;
            player.x = canvas.width / 2 - player.baseWidth / 2;
            player.displayWidth = player.baseWidth * scaleFactor;
            player.displayHeight = player.baseHeight * scaleFactor;
            player.targetWidth = player.baseWidth * scaleFactor;
            player.targetHeight = player.baseHeight * scaleFactor;
            player.speed = player.baseSpeed * scaleFactor;
            player.text = null;
            player.invincible = false;
            player.invincibleTimer = 0;
            player.sizeMultiplier = 1;
            player.sizeTransition = 1;
            player.explosion = null;
            lollipops = [];
            zelenskyHeads = [];
            putinHeads = [];
            trumpHeads = [];
            cybertrucks = [];
            javelins = [];
            missile = null;
            missileFlyingSound.pause();
            missileFlyingSound.currentTime = 0;
            textEffects = [];
            gamePaused = false;
            levelTransition = false;
            transitionTimer = 3;
            gibMoneyTimer = 0;
            trumpSpawnTimer = 39;
            cybertruckSpawnTimer = 33;
            javelinSpawnTimer = 26;
            lastTrumpSpawnTime = 60;
            lastCybertruckSpawnTime = 60;
            lastJavelinSpawnTime = 60;
            gameOverText = null;
            restartBtn.style.display = 'none';
            characterSelectBtn.style.display = 'none';
            touchLeft = false;
            touchRight = false;

            if (fullReset) {
                selectedVanceImg = null;
                gameActive = false;
                currentPowerUp = null;
                vanceInventory = null;
                vanceDropTimer = 30;
                vanceDrops = [];
            }
        }

        function resetGame() {
            resetGameState();
            gameActive = true;
            pauseBtn.disabled = false;
            resumeBtn.disabled = true;
            canvas.classList.remove('green-border');
            spawnZelenskyHeads(levels[0]);
            startGameTimer();
            lastTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function returnToCharacterSelect() {
            resetGameState(true);
            drawBackground();
            setupCharacterVideo();
            characterSelect.style.display = 'flex';
            selectedCharacterIndex = 0;
            updateCharacterSelection();
            document.removeEventListener('keydown', handleCharacterSelectKeys);
            document.addEventListener('keydown', handleCharacterSelectKeys);
        }

        function startGameTimer() {
            if (gameTimer) clearInterval(gameTimer);
            gameTimer = setInterval(() => {
                if (gameActive && !gamePaused && !levelTransition && timeLeft > 0) {
                    timeLeft -= 1;
                } else if (timeLeft <= 0) {
                    gameActive = false;
                    clearInterval(gameTimer);
                    gameTimer = null;
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    gameOverText = 'Game Over! Time Up! Final Score: ' + score;
                    restartBtn.style.display = 'block';
                    characterSelectBtn.style.display = 'block';
                }
            }, 1000);
        }

        function spawnLargePutinHead() {
            const padding = 100 * scaleFactor;
            const minX = padding;
            const maxX = canvas.width - (61.5 * scaleFactor) - padding; // 50% wider than regular Putin
            const spawnX = minX + Math.random() * (maxX - minX);
            putinHeads.push({
                x: spawnX,
                y: Math.random() * (canvas.height / 2),
                width: 61.5 * scaleFactor,  // 50% larger
                height: 91.5 * scaleFactor, // 50% larger
                displayWidth: 61.5 * scaleFactor,
                displayHeight: 91.5 * scaleFactor,
                speedX: (Math.random() - 0.5) * 2 * scaleFactor,
                speedY: (Math.random() - 0.5) * 2 * scaleFactor,
                text: "WWIII!",
                textTimer: Infinity,
                isSmall: false,
                isLarge: true,
                miniHeadsDestroyed: 0,
                requiredMiniHeads: 10
            });
        }

        function startNextLevel() {
            levelTransition = true;
            transitionTimer = 3;
            canvas.classList.add('green-border');
            lollipops = [];
            zelenskyHeads = [];
            putinHeads = [];
            trumpHeads = [];
            cybertrucks = [];
            javelins = [];
            missile = null;
            missileFlyingSound.pause();
            missileFlyingSound.currentTime = 0;
            textEffects = [];
            trumpSpawnTimer = 39;
            cybertruckSpawnTimer = 33;
            javelinSpawnTimer = 26;
            lastTrumpSpawnTime = 60;
            lastCybertruckSpawnTime = 60;
            lastJavelinSpawnTime = 60;
            vanceDropTimer = 30;
            vanceDrops = [];
            let countdown = setInterval(() => {
                transitionTimer--;
                timerSound.play();
                if (transitionTimer <= 0) {
                    clearInterval(countdown);
                    canvas.classList.remove('green-border');
                    timeLeft = 60;
                    player.width = player.baseWidth;
                    player.height = player.baseHeight;
                    player.displayWidth = player.baseWidth * scaleFactor;
                    player.displayHeight = player.baseHeight * scaleFactor;
                    player.targetWidth = player.baseWidth * scaleFactor;
                    player.targetHeight = player.baseHeight * scaleFactor;
                    player.x = canvas.width / 2 - player.baseWidth / 2;
                    player.speed = player.baseSpeed * scaleFactor;
                    player.text = null;
                    player.invincible = false;
                    player.invincibleTimer = 0;
                    player.sizeMultiplier = 1;
                    player.sizeTransition = 1;
                    player.explosion = null;
                    
                    // Special handling for level 5
                    if (level === 5) {
                        // Spawn 5 large Putin heads instead of Zelensky heads
                        for (let i = 0; i < 5; i++) {
                            spawnLargePutinHead();
                        }
                    } else {
                        spawnZelenskyHeads(levels[level - 1]);
                    }
                    
                    currentBackgroundIndex = (level - 1) % backgrounds.length;
                    levelTransition = false;
                    clapSound.play();
                }
            }, 1000);
        }

        function update() {
            if (!gameActive || gamePaused || levelTransition) return;

            if (!missile) {
                if (keys['ArrowLeft'] || keys['a']) {
                    player.x = Math.max(0, player.x - player.speed);
                }
                if (keys['ArrowRight'] || keys['d']) {
                    player.x = Math.min(canvas.width - player.displayWidth, player.x + player.speed);
                }
                if (touchLeft) {
                    player.x = Math.max(0, player.x - player.speed);
                }
                if (touchRight) {
                    player.x = Math.min(canvas.width - player.displayWidth, player.x + player.speed);
                }
            } else {
                if (!missile.hasExploded) {
                    if (keys['w']) missile.y -= missile.speed;
                    if (keys['s']) missile.y += missile.speed;
                    if (keys['a']) missile.x -= missile.speed;
                    if (keys['d']) missile.x += missile.speed;

                    missile.x = Math.max(0, Math.min(canvas.width - missile.width, missile.x));
                    missile.y = Math.max(0, Math.min(canvas.height - missile.height, missile.y));

                    missile.lifetime -= 1 / 60;
                    if (missile.lifetime <= 0) {
                        missile.hasExploded = true;
                        missile.explosion = {
                            x: missile.x + missile.width / 2,
                            y: missile.y + missile.height / 2,
                            baseWidth: 200 * scaleFactor,
                            baseHeight: 200 * scaleFactor,
                            width: 200 * scaleFactor,
                            height: 200 * scaleFactor,
                            timer: 2,
                            sizeTimer: 0.5
                        };
                        explosionSound.play();
                        missileFlyingSound.pause();
                        missileFlyingSound.currentTime = 0;
                    }

                    // Check collision with heads
                    zelenskyHeads = zelenskyHeads.filter(head => {
                        if (missile.x < head.x + head.width &&
                            missile.x + missile.width > head.x &&
                            missile.y < head.y + head.height &&
                            missile.y + missile.height > head.y) {
                            missile.hasExploded = true;
                            missile.explosion = {
                                x: missile.x + missile.width / 2,
                                y: missile.y + missile.height / 2,
                                baseWidth: 200 * scaleFactor,
                                baseHeight: 200 * scaleFactor,
                                width: 200 * scaleFactor,
                                height: 200 * scaleFactor,
                                timer: 2,
                                sizeTimer: 0.5
                            };
                            explosionSound.play();
                            missileFlyingSound.pause();
                            missileFlyingSound.currentTime = 0;
                            score++;
                            textEffects.push({
                                x: head.x + head.width / 2,
                                y: head.y + head.height / 2,
                                text: "Thank You",
                                textTimer: 1
                            });
                            hitSoundPool[hitSoundIndex].play();
                            hitSoundIndex = (hitSoundIndex + 1) % hitSoundPool.length;
                            return false;
                        }
                        return true;
                    });
                }

                if (missile.explosion) {
                    missile.explosion.timer -= 1 / 60;
                    if (missile.explosion.sizeTimer > 0) {
                        missile.explosion.sizeTimer -= 1 / 60;
                        const t = missile.explosion.sizeTimer / 0.5;
                        missile.explosion.width = missile.explosion.baseWidth * (1 + (1 - t));
                        missile.explosion.height = missile.explosion.baseHeight * (1 + (1 - t));
                    }

                    // Check for explosion damage
                    let killedHeads = 0;
                    zelenskyHeads = zelenskyHeads.filter(head => {
                        const dx = head.x + head.width / 2 - missile.explosion.x;
                        const dy = head.y + head.height / 2 - missile.explosion.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const explosionRadius = missile.explosion.width / 2;
                        if (distance < explosionRadius) {
                            killedHeads++;
                            score++;
                            textEffects.push({
                                x: head.x + head.width / 2,
                                y: head.y + head.height / 2,
                                text: "Thank You",
                                textTimer: 1
                            });
                            hitSoundPool[hitSoundIndex].play();
                            hitSoundIndex = (hitSoundIndex + 1) % hitSoundPool.length;
                            return false;
                        }
                        return true;
                    });

                    // Drop Vance power-up if multiple heads were killed
                    if (killedHeads >= 2) {
                        console.log(`Multiple kill detected: ${killedHeads} heads`); // Debug log
                        if (!vanceInventory) {
                            console.log('Spawning Vance power-up'); // Debug log
                            const randomVanceIndex = Math.floor(Math.random() * vanceDropImages.length);
                            textEffects.push({
                                x: missile.explosion.x,
                                y: missile.explosion.y - 20 * scaleFactor,
                                text: `Extra Life! (${killedHeads} kills)`,
                                textTimer: 2
                            });
                            vanceDrops.push({
                                x: missile.explosion.x - (50 * scaleFactor),
                                y: missile.explosion.y,
                                width: 100 * scaleFactor,
                                height: 62 * scaleFactor,
                                speedY: 1.5 * scaleFactor,
                                image: vanceDropImages[randomVanceIndex],
                                isInvulnerable: true // Make power-up immune to explosions
                            });
                            itemSound.play();
                        } else {
                            console.log('Player already has Vance power-up'); // Debug log
                        }
                    }

                    if (missile.explosion.timer <= 0) {
                        missile = null;
                        missileFlyingSound.pause();
                        missileFlyingSound.currentTime = 0;
                    }
                }
            }

            lollipops.forEach((lollipop, index) => {
                lollipop.y += lollipop.speed;
                if (lollipop.y < 0) lollipops.splice(index, 1);
            });

            zelenskyHeads.forEach((head, index) => {
                head.x += head.speedX;
                head.y += head.speedY;

                if (head.x <= 0 || head.x >= canvas.width - head.width) head.speedX *= -1;
                if (head.y <= 0 || head.y >= canvas.height - head.height) head.speedY *= -1;

                // Updated collision detection for player with Zelensky head
                const playerBottom = canvas.height;
                const playerTop = canvas.height - player.displayHeight;
                const headBottom = head.y + head.height;
                
                if (!player.invincible &&
                    player.x < head.x + head.width &&
                    player.x + player.displayWidth > head.x &&
                    playerTop < headBottom &&
                    playerBottom > head.y) {
                    if (vanceInventory) {
                        // Use extra life
                        const savedLevel = level;
                        resetGameState();
                        level = savedLevel;
                        gameActive = true;
                        vanceInventory = null; // Remove used power-up
                        currentBackgroundIndex = (level - 1) % backgrounds.length;
                        
                        // Special handling for level 5
                        if (level === 5) {
                            for (let i = 0; i < 5; i++) {
                                spawnLargePutinHead();
                            }
                        } else {
                            spawnZelenskyHeads(levels[level - 1]);
                        }
                        
                        // Reset timers
                        timeLeft = 60;
                        vanceDropTimer = 30;
                        startGameTimer();
                        lastTime = performance.now();
                    } else {
                        gameActive = false;
                        if (gameTimer) clearInterval(gameTimer);
                        gameTimer = null;
                        if (animationFrameId) cancelAnimationFrame(animationFrameId);
                        deadSound.play();
                        gameOverText = 'Game Over! Zelensky has your money! Final Score: ' + score;
                        restartBtn.style.display = 'block';
                        characterSelectBtn.style.display = 'block';
                    }
                    return;
                }
            });

            putinHeads.forEach((head, index) => {
                if (head.isSmall) {
                    head.y += head.speedY;
                    head.speedY += head.gravity;

                    head.x += head.speedX;
                    if (head.x <= 0) {
                        head.x = 0;
                        head.speedX = Math.abs(head.speedX);
                    } else if (head.x >= canvas.width - head.width) {
                        head.x = canvas.width - head.width;
                        head.speedX = -Math.abs(head.speedX);
                    }

                    if (head.y >= canvas.height - head.height && !head.hasLanded) {
                        head.y = canvas.height - head.height;
                        head.speedY = -Math.sqrt(2 * head.gravity * (canvas.height - head.height - head.spawnY));
                        head.hasLanded = true;
                    } else if (head.hasLanded && head.y >= canvas.height - head.height) {
                        head.y = canvas.height - head.height;
                        head.speedY = -Math.sqrt(2 * head.gravity * (canvas.height - head.height - head.spawnY));
                    }
                    if (head.y < 0) head.y = 0;
                } else {
                    head.x += head.speedX;
                    head.y += head.speedY;

                    if (head.x <= 0) {
                        head.x = 0;
                        head.speedX = Math.abs(head.speedX);
                    } else if (head.x >= canvas.width - head.width) {
                        head.x = canvas.width - head.width;
                        head.speedX = -Math.abs(head.speedX);
                    }
                    if (head.y <= 0 || head.y >= canvas.height - head.height) head.speedY *= -1;
                }

                // Updated collision detection for player with Putin head
                const playerBottom = canvas.height;
                const playerTop = canvas.height - player.displayHeight;
                const headBottom = head.y + head.height;
                
                if (!player.invincible &&
                    player.x < head.x + head.width &&
                    player.x + player.displayWidth > head.x &&
                    playerTop < headBottom &&
                    playerBottom > head.y) {
                    if (vanceInventory) {
                        // Use extra life
                        const savedLevel = level;
                        resetGameState();
                        level = savedLevel;
                        gameActive = true;
                        vanceInventory = null; // Remove used power-up
                        currentBackgroundIndex = (level - 1) % backgrounds.length;
                        
                        // Special handling for level 5
                        if (level === 5) {
                            for (let i = 0; i < 5; i++) {
                                spawnLargePutinHead();
                            }
                        } else {
                            spawnZelenskyHeads(levels[level - 1]);
                        }
                        
                        // Reset timers
                        timeLeft = 60;
                        vanceDropTimer = 30;
                        startGameTimer();
                        lastTime = performance.now();
                    } else {
                        gameActive = false;
                        if (gameTimer) clearInterval(gameTimer);
                        gameTimer = null;
                        if (animationFrameId) cancelAnimationFrame(animationFrameId);
                        deadSound.play();
                        gameOverText = 'Game Over! Putin Started WWIII! Final Score: ' + score;
                        restartBtn.style.display = 'block';
                        characterSelectBtn.style.display = 'block';
                    }
                    return;
                }
            });

            trumpSpawnTimer -= 1 / 60;
            if (trumpSpawnTimer <= 0 && timeLeft > 0) {
                spawnTrumpHead();
            }

            cybertruckSpawnTimer -= 1 / 60;
            if (cybertruckSpawnTimer <= 0 && timeLeft > 0) {
                spawnCybertruck();
            }

            javelinSpawnTimer -= 1 / 60;
            if (javelinSpawnTimer <= 0 && timeLeft > 0) {
                spawnJavelin();
            }

            trumpHeads.forEach((head, index) => {
                head.y += head.speedY;
                if (head.y > canvas.height) trumpHeads.splice(index, 1);

                if (head.x < player.x + player.displayWidth &&
                    head.x + head.width > player.x &&
                    head.y < canvas.height &&
                    head.y + head.height > canvas.height - player.displayHeight) {
                    trumpHeads.splice(index, 1);
                    player.invincible = true;
                    player.invincibleTimer += 10;
                    player.sizeMultiplier *= 1.5;
                    player.targetWidth = player.baseWidth * scaleFactor * player.sizeMultiplier;
                    player.targetHeight = player.baseHeight * scaleFactor * player.sizeMultiplier;
                    player.sizeTransition = 0;
                    player.text = "I'M NOT YELLING!";
                    player.textTimer = 2;
                    enlargedSound.play();
                }
            });

            cybertrucks.forEach((truck, index) => {
                truck.y += truck.speedY;
                if (truck.y > canvas.height) cybertrucks.splice(index, 1);

                if (truck.x < player.x + player.displayWidth &&
                    truck.x + truck.width > player.x &&
                    truck.y < canvas.height &&
                    truck.y + truck.height > canvas.height - player.displayHeight) {
                    cybertrucks.splice(index, 1);
                    currentPowerUp = 'cybertruck';
                    itemSound.play();
                }
            });

            javelins.forEach((javelin, index) => {
                javelin.y += javelin.speedY;
                if (javelin.y > canvas.height) javelins.splice(index, 1);

                if (javelin.x < player.x + player.displayWidth &&
                    javelin.x + javelin.width > player.x &&
                    javelin.y < canvas.height &&
                    javelin.y + javelin.height > canvas.height - player.displayHeight) {
                    javelins.splice(index, 1);
                    currentPowerUp = 'javelin';
                    itemSound.play();
                }
            });

            if (player.explosion) {
                player.explosion.timer -= 1 / 60;
                if (player.explosion.sizeTimer > 0) {
                    player.explosion.sizeTimer -= 1 / 60;
                    const t = player.explosion.sizeTimer / 0.5;
                    player.explosion.width = player.explosion.baseWidth * (1 + (1 - t));
                    player.explosion.height = player.explosion.baseHeight * (1 + (1 - t));
                } else {
                    player.explosion.width = player.explosion.baseWidth;
                    player.explosion.height = player.explosion.baseHeight;
                }

                killedHeads = 0;
                zelenskyHeads = zelenskyHeads.filter(head => {
                    const dx = head.x + head.width / 2 - player.explosion.x;
                    const dy = head.y + head.height / 2 - player.explosion.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const explosionRadius = player.explosion.width / 2;
                    if (distance < explosionRadius) {
                        killedHeads++;
                        score++;
                        textEffects.push({
                            x: head.x + head.width / 2,
                            y: head.y + head.height / 2,
                            text: "Thank You",
                            textTimer: 1
                        });
                        hitSoundPool[hitSoundIndex].play();
                        hitSoundIndex = (hitSoundIndex + 1) % hitSoundPool.length;
                        return false;
                    }
                    return true;
                });

                // Drop Vance power-up if multiple heads were killed
                if (killedHeads >= 2 && !vanceInventory) {
                    const randomVanceIndex = Math.floor(Math.random() * vanceDropImages.length);
                    vanceDrops.push({
                        x: player.explosion.x - (50 * scaleFactor),
                        y: player.explosion.y,
                        width: 100 * scaleFactor,
                        height: 62 * scaleFactor,
                        speedY: 2.5 * scaleFactor,
                        image: vanceDropImages[randomVanceIndex]
                    });
                }

                putinHeads = putinHeads.filter(head => {
                    const dx = head.x + head.width / 2 - player.explosion.x;
                    const dy = head.y + head.height / 2 - player.explosion.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const explosionRadius = player.explosion.width / 2;
                    if (distance < explosionRadius) {
                        killedHeads++;
                        score++;
                        textEffects.push({
                            x: head.x + head.width / 2,
                            y: head.y + head.height / 2,
                            text: "Thank You",
                            textTimer: 1
                        });
                        hitSoundPool[hitSoundIndex].play();
                        hitSoundIndex = (hitSoundIndex + 1) % hitSoundPool.length;
                        return false;
                    }
                    return true;
                });

                // Drop Vance power-up if multiple heads were killed
                if (killedHeads >= 2 && !vanceInventory) {
                    const randomVanceIndex = Math.floor(Math.random() * vanceDropImages.length);
                    vanceDrops.push({
                        x: player.explosion.x - (50 * scaleFactor),
                        y: player.explosion.y,
                        width: 100 * scaleFactor,
                        height: 62 * scaleFactor,
                        speedY: 2.5 * scaleFactor,
                        image: vanceDropImages[randomVanceIndex]
                    });
                }

                if (player.explosion.timer <= 0) {
                    player.explosion = null;
                }
            }

            textEffects.forEach((effect, index) => {
                effect.textTimer -= 1 / 60;
                if (effect.textTimer <= 0) {
                    textEffects.splice(index, 1);
                }
            });

            lollipops.forEach((lollipop, lollipopIndex) => {
                zelenskyHeads.forEach((head, headIndex) => {
                    if (lollipop.x < head.x + head.width &&
                        lollipop.x + lollipop.width > head.x &&
                        lollipop.y < head.y + head.height &&
                        lollipop.y + lollipop.height > head.y) {
                        lollipops.splice(lollipopIndex, 1);
                        zelenskyHeads.splice(headIndex, 1);
                        score++;
                        textEffects.push({
                            x: head.x + head.width / 2,
                            y: head.y + head.height / 2,
                            text: "Thank You",
                            textTimer: 1
                        });
                        hitSoundPool[hitSoundIndex].play();
                        hitSoundIndex = (hitSoundIndex + 1) % hitSoundPool.length;
                        if (!player.invincible) {
                            player.displayWidth *= 1.02;
                            player.displayHeight *= 1.02;
                            player.sizeMultiplier *= 1.02;
                            player.targetWidth = player.displayWidth;
                            player.targetHeight = player.displayHeight;
                        }
                        if (zelenskyHeads.length === 0 && putinHeads.length === 0) {
                            spawnPutinHead();
                        }
                        return;
                    }
                });

                putinHeads.forEach((head, headIndex) => {
                    const collisionWidth = head.width;
                    const collisionHeight = head.height;
                    
                    if (lollipop.x < head.x + collisionWidth &&
                        lollipop.x + lollipop.width > head.x &&
                        lollipop.y < head.y + collisionHeight &&
                        lollipop.y + lollipop.height > head.y) {
                        // Remove the lollipop first
                        lollipops.splice(lollipopIndex, 1);
                        
                        // Increment score and add text effect
                        score++;
                        textEffects.push({
                            x: head.x + head.width / 2,
                            y: head.y + head.height / 2,
                            text: "Thank You",
                            textTimer: 1
                        });
                        hitSoundPool[hitSoundIndex].play();
                        hitSoundIndex = (hitSoundIndex + 1) % hitSoundPool.length;
                        
                        if (head.isLarge) {
                            // For large Putin heads in level 5, spawn mini heads and remove the large head immediately
                            spawnSmallPutinHeads(head.x, head.y, 2);
                            putinHeads.splice(headIndex, 1);
                        } else if (!head.isSmall) {
                            // For regular Putin heads
                            const splitCount = Math.min(2 + (level - 1) * 2, 20);
                            spawnSmallPutinHeads(head.x, head.y, splitCount);
                            putinHeads.splice(headIndex, 1);
                        } else {
                            // For small Putin heads
                            putinHeads.splice(headIndex, 1);
                        }
                        return;
                    }
                });
            });

      if (zelenskyHeads.length === 0 && putinHeads.length === 0 && level <= 10 && !levelTransition) {
    // For level 5, check if all required mini heads were destroyed
    if (level === 5) {
        const allLargePutinHeadsComplete = putinHeads.every(head => 
            !head.isLarge || head.miniHeadsDestroyed >= head.requiredMiniHeads
        );
        if (allLargePutinHeadsComplete) {
            level++;
            if (level > 10) {
                gameActive = false;
                if (gameTimer) clearInterval(gameTimer);
                gameTimer = null;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                gameOverText = 'You Won! No Questions Pwease!';
                restartBtn.style.display = 'none';
                characterSelectBtn.style.display = 'block';
            } else {
                startNextLevel();
            }
        }
    } else {
        level++;
        if (level > 10) {
            gameActive = false;
            if (gameTimer) clearInterval(gameTimer);
            gameTimer = null;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameOverText = 'You Won! No Questions Pwease!';
            restartBtn.style.display = 'none';
            characterSelectBtn.style.display = 'block';
        } else {
            startNextLevel();
        }
    }
}

            if (player.invincible) {
                player.invincibleTimer -= 1 / 60;
                if (player.sizeTransition < 1) {
                    player.sizeTransition += 1 / (60 * player.sizeTransitionSpeed);
                    if (player.sizeTransition > 1) player.sizeTransition = 1;
                    const t = easeInOut(player.sizeTransition);
                    player.displayWidth = (player.baseWidth * scaleFactor) + (player.targetWidth - (player.baseWidth * scaleFactor)) * t;
                    player.displayHeight = (player.baseHeight * scaleFactor) + (player.targetHeight - (player.baseHeight * scaleFactor)) * t;
                }
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                    player.targetWidth = player.baseWidth * scaleFactor;
                    player.targetHeight = player.baseHeight * scaleFactor;
                    player.sizeTransition = 0;
                }
            } else if (player.displayWidth > player.targetWidth && player.sizeTransition < 1) {
                player.sizeTransition += 1 / (60 * player.sizeTransitionSpeed);
                if (player.sizeTransition > 1) player.sizeTransition = 1;
                const t = easeInOut(player.sizeTransition);
                player.displayWidth = player.targetWidth + ((player.baseWidth * scaleFactor * player.sizeMultiplier) - player.targetWidth) * (1 - t);
                player.displayHeight = player.targetHeight + ((player.baseHeight * scaleFactor * player.sizeMultiplier) - player.targetHeight) * (1 - t);
                if (player.displayWidth < player.baseWidth * scaleFactor) {
                    player.displayWidth = player.baseWidth * scaleFactor;
                    player.displayHeight = player.baseHeight * scaleFactor;
                }
            }

            if (player.textTimer > 0) {
                player.textTimer -= 1 / 60;
                if (player.textTimer <= 0) player.text = null;
            }

            gibMoneyTimer += 1 / 60;
            if (gibMoneyTimer >= 5) {
                zelenskyHeads.forEach(head => {
                    head.text = "Gib Money";
                    head.textTimer = 1;
                });
                gibMoneyTimer = 0;
            }
            zelenskyHeads.forEach(head => {
                if (head.textTimer > 0) {
                    head.textTimer -= 1 / 60;
                    if (head.textTimer <= 0) head.text = null;
                }
            });

            // Update Vance drop timer - Moved outside of any conditions
            if (timeLeft <= 30 && vanceDropTimer > 0) {
                vanceDropTimer -= 1/60;
                if (vanceDropTimer <= 0) {
                    // Drop a random Vance power-up
                    const randomVanceIndex = Math.floor(Math.random() * vanceDropImages.length);
                    vanceDrops.push({
                        x: Math.random() * (canvas.width - 100 * scaleFactor),
                        y: -62 * scaleFactor,
                        width: 100 * scaleFactor,
                        height: 62 * scaleFactor,
                        speedY: 2.5 * scaleFactor,
                        image: vanceDropImages[randomVanceIndex]
                    });
                }
            }

            // Update Vance drops
            vanceDrops.forEach((drop, index) => {
                drop.y += drop.speedY;
                
                // Only remove if off screen
                if (drop.y > canvas.height) {
                    console.log('Vance power-up went off screen'); // Debug log
                    vanceDrops.splice(index, 1);
                    return;
                }

                // Check collision with player
                if (drop.x < player.x + player.displayWidth &&
                    drop.x + drop.width > player.x &&
                    drop.y < canvas.height &&
                    drop.y + drop.height > canvas.height - player.displayHeight) {
                    console.log('Player collected Vance power-up'); // Debug log
                    vanceDrops.splice(index, 1);
                    vanceInventory = drop.image;
                    itemSound.play();
                }
            });
        }

        function draw() {
            if (levelTransition) {
                const flash = Math.floor(transitionTimer * 4) % 2 === 0;
                ctx.fillStyle = flash ? 'rgba(255, 0, 0, 0.5)' : 'rgba(255, 0, 0, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            drawBackground();

            if (player.invincible) {
                if (player.invincibleTimer <= 3) {
                    const flash = Math.floor(player.invincibleTimer * 4) % 2 === 0;
                    ctx.shadowColor = flash ? 'red' : 'transparent';
                    ctx.shadowBlur = flash ? 20 : 0;
                } else {
                    ctx.shadowColor = 'red';
                    ctx.shadowBlur = 20;
                }
            }
            ctx.drawImage(selectedVanceImg, player.x, canvas.height - player.displayHeight, player.displayWidth, player.displayHeight);
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            if (player.text) {
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.font = `${20 * scaleFactor}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(player.text, player.x + player.displayWidth / 2, canvas.height - player.displayHeight - 10 * scaleFactor);
                ctx.shadowBlur = 0;
            }

            if (player.explosion) {
                const x = player.explosion.x - player.explosion.width / 2;
                const y = player.explosion.y - player.explosion.height / 2;
                ctx.drawImage(explosionImg, x, y, player.explosion.width, player.explosion.height);
            }

            lollipops.forEach(lollipop => {
                ctx.drawImage(lollipopImg, lollipop.x, lollipop.y, lollipop.width, lollipop.height);
            });

            zelenskyHeads.forEach(head => {
                ctx.drawImage(zelenskyImg, head.x, head.y, head.displayWidth, head.displayHeight);
                if (head.text) {
                    ctx.fillStyle = 'white';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.font = `${16 * scaleFactor}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(head.text, head.x + head.displayWidth / 2, head.y - 10 * scaleFactor);
                    ctx.shadowBlur = 0;
                }
            });

            putinHeads.forEach(head => {
                ctx.drawImage(putinImg, head.x, head.y, head.displayWidth, head.displayHeight);
                if (head.text) {
                    ctx.fillStyle = 'white';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.font = `${16 * scaleFactor}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(head.text, head.x + head.displayWidth / 2, head.y - 10 * scaleFactor);
                    ctx.shadowBlur = 0;
                }
            });

            trumpHeads.forEach(head => {
                ctx.drawImage(trumpImg, head.x, head.y, head.width, head.height);
                if (head.text) {
                    ctx.fillStyle = 'white';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.font = `${16 * scaleFactor}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(head.text, head.x + head.width / 2, head.y - 10 * scaleFactor);
                    ctx.shadowBlur = 0;
                }
            });

            cybertrucks.forEach(truck => {
                ctx.drawImage(cybertruckImg, truck.x, truck.y, truck.width, truck.height);
            });

            javelins.forEach(javelin => {
                ctx.drawImage(javelinImg, javelin.x, javelin.y, javelin.width, javelin.height);
            });

            if (currentPowerUp === 'cybertruck') {
                ctx.drawImage(cybertruckImg, canvas.width - 60 * scaleFactor, canvas.height - 30 * scaleFactor, 60 * scaleFactor, 30 * scaleFactor);
            } else if (currentPowerUp === 'javelin') {
                ctx.drawImage(javelinImg, canvas.width - 60 * scaleFactor, canvas.height - 60 * scaleFactor, 60 * scaleFactor, 60 * scaleFactor);
            }

            // Draw missile and its explosion
            if (missile) {
                // Draw missile
                ctx.save();
                ctx.drawImage(missileImg, missile.x, missile.y, missile.width, missile.height);
                ctx.restore();

                // Draw explosion if it exists
                if (missile.explosion) {
                    ctx.save();
                    const x = missile.explosion.x - missile.explosion.width / 2;
                    const y = missile.explosion.y - missile.explosion.height / 2;
                    ctx.drawImage(explosionImg, x, y, missile.explosion.width, missile.explosion.height);
                    ctx.restore();
                }
            }

            textEffects.forEach(effect => {
                if (effect.textTimer > 0) {
                    ctx.fillStyle = 'white';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.font = `${16 * scaleFactor}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(effect.text, effect.x, effect.y - 10 * scaleFactor);
                    ctx.shadowBlur = 0;
                }
            });

            if (levelTransition) {
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.font = `${40 * scaleFactor}px Arial`;
                ctx.textAlign = 'center';
                const timerText = transitionTimer === 3 ? "3, 2, 1" : transitionTimer === 2 ? "2, 1" : "1";
                ctx.fillText(timerText, canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
            }

            if (gameOverText) {
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.font = `${30 * scaleFactor}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(gameOverText, canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
            }
            
            // Draw gamertag directly on the canvas
            if (playerGamertag) {
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.font = `${18 * scaleFactor}px Arial`;
                ctx.textAlign = 'left';
                ctx.fillText(playerGamertag, 10, 30);
                ctx.shadowBlur = 0;
            }

            document.getElementById('level').textContent = `Level: ${level}`;
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('timer').textContent = `Timer: ${Math.floor(timeLeft)}`;
            highScoreDisplay.textContent = `High Score: ${highScore}`;

            // Draw Vance drops
            vanceDrops.forEach(drop => {
                ctx.drawImage(drop.image, drop.x, drop.y, drop.width, drop.height);
            });

            // Draw Vance inventory if exists
            if (vanceInventory) {
                ctx.drawImage(vanceInventory, 10, canvas.height - 72 * scaleFactor, 100 * scaleFactor, 62 * scaleFactor);
            }
        }

        let lastTime = performance.now();
        function gameLoop(time) {
            if (!gameActive || gamePaused || (levelTransition && transitionTimer > 0)) {
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            const delta = (time - lastTime) / 1000;
            lastTime = time;

            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (gameTimer) clearInterval(gameTimer);

            // We don't need to update the playerGamertagDisplay anymore since we're
            // drawing directly on the canvas
            // playerGamertagDisplay.textContent = playerGamertag;

            gameActive = true;
            spawnZelenskyHeads(levels[0]);
            startGameTimer();
            lastTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Initially hide characterSelect and show gamertag entry first
        characterSelect.style.display = 'none';

        // Add admin level skip functionality
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const adminInput = document.getElementById('adminInput');
                // Only show admin input if game is active and character is selected
                if (gameActive && selectedVanceImg && !characterSelect.style.display.includes('flex') && !gamertagEntry.style.display.includes('flex')) {
                    adminInput.style.display = 'block';
                    adminInput.focus();
                    if (!gamePaused) {
                        gamePaused = true;
                        pauseBtn.disabled = true;
                        resumeBtn.disabled = false;
                    }
                }
            }
        });

        document.getElementById('adminInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const command = e.target.value.toLowerCase();
                let targetLevel = null;
                
                // Check for pwease commands (now checking for pwease1 through pwease10)
                if (command.startsWith('pwease')) {
                    const levelNum = parseInt(command.substring(6)); // Changed from charAt(5) to substring(6)
                    if (!isNaN(levelNum) && levelNum >= 1 && levelNum <= 10) {
                        targetLevel = levelNum;
                    }
                }

                if (targetLevel !== null && gameActive) {
                    level = targetLevel;
                    currentBackgroundIndex = (level - 1) % backgrounds.length;
                    timeLeft = 60;
                    
                    // Clear existing entities
                    lollipops = [];
                    zelenskyHeads = [];
                    putinHeads = [];
                    trumpHeads = [];
                    cybertrucks = [];
                    javelins = [];
                    missile = null;
                    textEffects = [];
                    
                    // Reset spawn timers
                    trumpSpawnTimer = 39;
                    cybertruckSpawnTimer = 33;
                    javelinSpawnTimer = 26;
                    lastTrumpSpawnTime = 60;
                    lastCybertruckSpawnTime = 60;
                    lastJavelinSpawnTime = 60;
                    
                    // Special handling for level 5
                    if (level === 5) {
                        // Spawn 5 large Putin heads
                        for (let i = 0; i < 5; i++) {
                            spawnLargePutinHead();
                        }
                    } else {
                        // Spawn regular enemies for other levels
                        spawnZelenskyHeads(levels[level - 1]);
                    }
                    
                    // Reset player position and state
                    player.x = canvas.width / 2 - player.baseWidth / 2;
                    player.displayWidth = player.baseWidth * scaleFactor;
                    player.displayHeight = player.baseHeight * scaleFactor;
                    player.targetWidth = player.baseWidth * scaleFactor;
                    player.targetHeight = player.baseHeight * scaleFactor;
                    player.invincible = false;
                    player.invincibleTimer = 0;
                    player.sizeMultiplier = 1;
                    player.sizeTransition = 1;
                    player.explosion = null;
                    
                    // Resume game
                    gameActive = true;
                    gamePaused = false;
                    pauseBtn.disabled = false;
                    resumeBtn.disabled = true;
                    
                    // Reset and start timer
                    if (gameTimer) clearInterval(gameTimer);
                    startGameTimer();
                    lastTime = performance.now();
                }
                
                e.target.style.display = 'none';
                e.target.value = '';
                if (gameActive && gamePaused) {
                    gamePaused = false;
                    pauseBtn.disabled = false;
                    resumeBtn.disabled = true;
                    lastTime = performance.now();
                }
            } else if (e.key === 'Escape') {
                e.target.style.display = 'none';
                e.target.value = '';
                if (gameActive && gamePaused) {
                    gamePaused = false;
                    pauseBtn.disabled = false;
                    resumeBtn.disabled = true;
                    lastTime = performance.now();
                }
            }
            e.stopPropagation();
        });
        
        // Add control tips toggle functionality
        const controlTipsToggle = document.getElementById('controlTipsToggle');
        const controlInfo = document.getElementById('controlInfo');
        
        controlTipsToggle.addEventListener('click', () => {
            controlInfo.classList.toggle('visible');
        });
        
        // Hide controls info by default on mobile
        if (window.innerWidth <= 768 || window.matchMedia('(pointer: coarse)').matches) {
            controlInfo.classList.remove('visible');
        }
    </script>
</body>
</html>
